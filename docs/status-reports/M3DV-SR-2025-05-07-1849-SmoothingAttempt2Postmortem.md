# Status Report: Frontend Smoothing Attempt 2 - Post-Mortem & Plan V3

**Date:** 2025-05-07
**Report ID:** M3DV-SR-2025-05-07-1849-SmoothingAttempt2Postmortem

## Session Overview
- **Focus Area(s):** Frontend Animation Smoothing (`feat/frontend-smoothing-v2` branch)
- **Goal:** Cautiously implement frontend sequential animation smoothing using an incremental approach, ensuring primitive correctness at each step before adding blending.
- **Outcome:** The attempt resulted in significant regressions across multiple primitive types, necessitating a post-mortem and reset.

## Summary of Attempt 2 (`feat/frontend-smoothing-v2`)
Following the failure of Attempt 1, a more methodical approach was taken:
1.  **Revised Plan:** Adopted an incremental plan: (1) Spline Position + LERP Target -> (2) Spline Position + Slerp Orientation -> (3) Add Corner Blending. Emphasized broad testing at each stage.
2.  **Backend Handler Fixes:** Identified and corrected fundamental flaws in `handlePanStep.ts` (to generate intermediate steps) and `handlePedestalStep.ts` (to ensure correct target movement for fixed orientation). Also adjusted `handleOrbitStep.ts` waypoint density (`anglePerStep=10`) and easing (`linear`).
3.  **V1 Implementation (Pos Spline + Target LERP):** Successfully implemented `PathProcessor.processV1` and updated `AnimationController` to use Catmull-Rom for position while retaining target LERP. Basic primitives functioned correctly.
4.  **V2 Implementation (Pos Spline + Slerp Orient):** Updated `PathProcessor` (`processV2`) to calculate per-command `keyframeQuaternions`. Updated `AnimationController` to use Slerp for orientation. Initial tests showed individual primitives (Pan, Pedestal, Orbit) executed correctly, although Orbit exhibited visual jitter.
5.  **V2 + Corner Blending:** Re-enabled Phase 2 corner blending logic (corner detection, blend point injection) in `PathProcessor.processV2`.

## Key Issues & Failures
- **Fundamental Architectural Incompatibility:** The shift from per-segment LERP to a pre-processed spline/Slerp system broke compatibility with backend handlers (like `pan`, `tilt`) that relied on sequential target changes at fixed positions. The pre-processing logic (filtering, decoupled orientation) failed to preserve the necessary data structure for these primitives.
- **Widespread Regressions:** Simple, single-primitive commands (e.g., "pan left 45", "pedestal up") failed to execute correctly (no movement, incorrect orientation/tilting) even after reverting some frontend changes, indicating the issue stemmed from the core architectural change.
- **Misleading Intermediate States:** Focusing solely on improving the dolly-to-orbit transition masked underlying issues and led to cascading problems.
- **Frontend Orientation Handling:** Both dynamic `lookAt` (using a fixed target) and Slerp (when fed incomplete/incorrectly filtered orientation keyframes) failed to handle all primitive types correctly.
- **Ineffective Blending Parameter Tuning:** Efforts to tune blend constants (`BLEND_OFFSET_FRACTION`, `MIN_BLEND_OFFSET`) were largely ineffective due to geometric limitations imposed by backend waypoint density (especially short subsequent segments capping the maximum blend offset).
- **Transition Failure (Sequence Orbit):** When corner blending was enabled, sequences ending in Orbit failed rotationally ("truck+pan"), indicating a timing/synchronization mismatch between the blended position spline and the Slerp driven by original segment durations.

## Lessons Learned
- **Broad Testing is Crucial:** Significant architectural changes require thorough testing across all core functionalities at each incremental step, not just the target use case.
- **Handler Output Matters:** Frontend animation systems are highly dependent on the structure and correctness of the command sequences generated by backend handlers. The spline/Slerp approach requires handlers to represent continuous motion (position and/or orientation) with appropriate intermediate steps and durations.
- **Decoupling Position/Orientation:** While powerful, decoupling position (spline) and orientation (Slerp) requires careful management of keyframe generation and filtering in the pre-processing step (`PathProcessor`) to avoid losing critical orientation information for primitives like pan/tilt.
- **Synchronization is Key:** Decoupling position (global spline) and orientation (per-segment Slerp) requires careful synchronization, especially when geometric path blending alters the effective timing/length of transition segments. Using original segment durations for Slerp while sampling a blended position spline appears problematic.

## Decision
The `feat/frontend-smoothing-v2` branch will be abandoned. Development will reset to `main`. A pause for research into robust spline/orientation synchronization techniques or alternative animation libraries/approaches for Three.js is recommended before Attempt 3.

## Plan for Next Attempt (`feat/frontend-smoothing-v3`)
1.  **(Research):** Investigate established libraries or techniques for synchronized spline-based camera path animation with orientation control (e.g., using path length for Slerp, coupled interpolation, existing R3F animation tools).
2.  **(Implement V1 - Stable Base):** Based on research, implement the simplest robust method. This might be:
    *   **Option A (Modified Spline+Slerp):** Spline position, Slerp orientation, but with timing synchronized based on geometric path progress, not original segment durations. Requires careful `PathProcessor` output and `AnimationController` logic.
    *   **Option B (Simplify Frontend):** Revert `AnimationController` to `main`'s LERP logic. Modify `PathProcessor` to *only* inject geometric blend points into the command list *before* it's processed by the LERP controller. Test if this simpler blending provides sufficient visual improvement.
3.  **(Test V1):** Thoroughly test ALL primitives and basic sequences with the chosen V1 approach.
4.  **(Implement V2 - Advanced Blending/Smoothing):** If V1 is stable and successful, incrementally add more advanced features (like more sophisticated blending curves or potentially replacing LERP with Slerp if Option B was chosen and needs better orientation).
5.  **(Backend Tuning):** Adjust backend handler densities only as a final optimization step if needed. 